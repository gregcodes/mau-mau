{
    "docs": [
        {
            "location": "/",
            "text": "Mau Mau\n\n\n\n\nPlay is the highest form of research\n\n\n-- \nProbably not Albert Einstein\n\n\n\n\nThis project aims to be a learning tool. Emphasis is put on \npythonic\n ways to code and on using the power of the Open Source ecosystem. This is not a toy example, but the nasty details that usually screw with the nice and simple design and make the code grow tentacles and other cruft is not (yet) part of the code, so it can still be read like a nice little completely non-linear story (hopefully). It came into live in a non-linear fashion and should also be read that way.\n\n\nI will try to keep it that way even if it has to grow some tentacles like fixing the broken unicode support in Windows terminals and other things the real world comes up with to complicate our beautiful simple projects.\n\n\nFeatures\n\n\nThe game\n\n\n\n\nComplete \nrules of Mau Mau\n\n\ntwo different strategies:\n\n\nsimple random strategy for a computer player\n\n\nstrategy that adds interactivity so a human can play against the computer\n\n\n\n\n\n\nFunctions to run multiple games and collect stats\n\n\nInstallable as command line tool\n\n\n\n\nImplementation and tools\n\n\n\n\nautomatic tests\n with py.test, tox and Travis CI\n\n\nFlexible \ncommand line interface\n (add new functions without adjusting code)\n\n\nUse of \nmagic methods\n to create custom classes which behave like inbuilt data types\n\n\nQuality Assurance: flake8, QuantifiedCode, py.test, doctests, Travis CI\n\n\nAutomatic generation and deployment of documentation with MkDocs\n\n\nLogging with stdlib \nlogging module\n\n\nDeveloper task automation with tox (building and deploying docs, running tests)",
            "title": "Home"
        },
        {
            "location": "/#mau-mau",
            "text": "Play is the highest form of research  --  Probably not Albert Einstein   This project aims to be a learning tool. Emphasis is put on  pythonic  ways to code and on using the power of the Open Source ecosystem. This is not a toy example, but the nasty details that usually screw with the nice and simple design and make the code grow tentacles and other cruft is not (yet) part of the code, so it can still be read like a nice little completely non-linear story (hopefully). It came into live in a non-linear fashion and should also be read that way.  I will try to keep it that way even if it has to grow some tentacles like fixing the broken unicode support in Windows terminals and other things the real world comes up with to complicate our beautiful simple projects.",
            "title": "Mau Mau"
        },
        {
            "location": "/#features",
            "text": "",
            "title": "Features"
        },
        {
            "location": "/#the-game",
            "text": "Complete  rules of Mau Mau  two different strategies:  simple random strategy for a computer player  strategy that adds interactivity so a human can play against the computer    Functions to run multiple games and collect stats  Installable as command line tool",
            "title": "The game"
        },
        {
            "location": "/#implementation-and-tools",
            "text": "automatic tests  with py.test, tox and Travis CI  Flexible  command line interface  (add new functions without adjusting code)  Use of  magic methods  to create custom classes which behave like inbuilt data types  Quality Assurance: flake8, QuantifiedCode, py.test, doctests, Travis CI  Automatic generation and deployment of documentation with MkDocs  Logging with stdlib  logging module  Developer task automation with tox (building and deploying docs, running tests)",
            "title": "Implementation and tools"
        },
        {
            "location": "/guide/installation/",
            "text": "Installation\n\n\n[Optional but recommended] Prepare a virtualenv\n\n\nYou need \nPython3\n and you should really install this in a \nvirtualenv\n. This should work out of the box. If not, you might be on Linux and are bitten by \nthis\n. \nsudo apt-get install python3-pip\n should solve the problem - otherwise have a look at the \npip documentation\n.\n\n\n$ python3 -m venv mau-mau-env\n\n\n\nActivation of virtualenvs is sadly still one of the things that is not os independent, so you will hve to look \nhere\n how to do that in your os. The most common cases are:\n\n\n$ source mau-mau-env/bin/activate  # most linux shells\n$ mau-mau-env\\Scripts\\activate.bat  # Windows cmd.exe\n\n\n\nDeactivate with:\n\n\n$ deactivate\n\n\n\nInstall from Github\n\n\nInstall the latest code directly from github:\n\n\n$ pip install https://github.com/obestwalter/mau-mau/zipball/master\n\n\n\nTo install a specific version just replace \nmaster\n with the version you want to install (e.g. \n1.1.0\n). The different versions can be seen in the \nrelease section\n of a Github project.\n\n\nInstall from a downloaded archive\n\n\nOn the \nreleases page\n you can download zip archives and install them like:\n\n\n$ pip install \n/path/to/downloaded/zip/archive\n\n\n\n\n[Not implemented] install directly from \nPyPI\n\n\nThis would mean uploading the package to the official Python Package Index (PyPI -- formerly known as the cheese shop -- documented \nhere\n) ... it's not hard to do but not necessary for a learning tool like this, so I just mention it here, because that is the official way for \"real\" software. It then could be installed by simply typing:\n\n\n$ pip install mau-mau",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#optional-but-recommended-prepare-a-virtualenv",
            "text": "You need  Python3  and you should really install this in a  virtualenv . This should work out of the box. If not, you might be on Linux and are bitten by  this .  sudo apt-get install python3-pip  should solve the problem - otherwise have a look at the  pip documentation .  $ python3 -m venv mau-mau-env  Activation of virtualenvs is sadly still one of the things that is not os independent, so you will hve to look  here  how to do that in your os. The most common cases are:  $ source mau-mau-env/bin/activate  # most linux shells\n$ mau-mau-env\\Scripts\\activate.bat  # Windows cmd.exe  Deactivate with:  $ deactivate",
            "title": "[Optional but recommended] Prepare a virtualenv"
        },
        {
            "location": "/guide/installation/#install-from-github",
            "text": "Install the latest code directly from github:  $ pip install https://github.com/obestwalter/mau-mau/zipball/master  To install a specific version just replace  master  with the version you want to install (e.g.  1.1.0 ). The different versions can be seen in the  release section  of a Github project.",
            "title": "Install from Github"
        },
        {
            "location": "/guide/installation/#install-from-a-downloaded-archive",
            "text": "On the  releases page  you can download zip archives and install them like:  $ pip install  /path/to/downloaded/zip/archive",
            "title": "Install from a downloaded archive"
        },
        {
            "location": "/guide/installation/#not-implemented-install-directly-from-pypi",
            "text": "This would mean uploading the package to the official Python Package Index (PyPI -- formerly known as the cheese shop -- documented  here ) ... it's not hard to do but not necessary for a learning tool like this, so I just mention it here, because that is the official way for \"real\" software. It then could be installed by simply typing:  $ pip install mau-mau",
            "title": "[Not implemented] install directly from PyPI"
        },
        {
            "location": "/guide/usage/",
            "text": "Usage\n\n\nCommand line access\n\n\nAfter installation you have an additional command in your virtualenv: \nmau-mau\n. The default behaviour if you call it without parameters is to simulate a simple game of Mau Mau between three computer players (and you can see the hands of all the players and every step of the game).\n\n\n\n\nmau-mau\n: Play single game with high verbosity settings in the logger\n\n\nmau-mau \nstats.function\n: e.g. \nmau-mau mean_turns\n - the argument will be passed to \nget_function_from_name\n that fetches a function object of the same name from \nstats.py\n and executes it. This is a very simple way to create a flexible command line interface that does not need to be changed if you create more statistics functions in \nstats.py\n. Adding a new function to \nstats.py\n will automatically make it accessible through the command line interface.\n\n\nmau-mau human\n ... or any other argument that does not map to a function in stats: play a game against the computer\n\n\n\n\nRun a simple simulation\n\n\n    $ cd \n/path/to/your/clone\n\n    $ mau-mau\n\n\n\noutput like:\n\n\nroot                53  main             : play_simple_game() ...\nmau_mau.subjects    28  invite           : invite [Player('Player 1', Hand([])), Player('Player 2', Hand([])), Player('Player 3', Hand([]))] to: Table(None, None)\nmau_mau.subjects    100 draw             : Player 1 \n- Card('10', '\u2663')\nmau_mau.subjects    100 draw             : Player 1 \n- Card('8', '\u2663')\nmau_mau.subjects    100 draw             : Player 1 \n- Card('Ace', '\u2663')\nmau_mau.subjects    100 draw             : Player 1 \n- Card('Ace', '\u2660')\nmau_mau.subjects    100 draw             : Player 1 \n- Card('9', '\u2665')\nmau_mau.subjects    100 draw             : Player 2 \n- Card('8', '\u2665')\nmau_mau.subjects    100 draw             : Player 2 \n- Card('7', '\u2663')\nmau_mau.subjects    100 draw             : Player 2 \n- Card('Queen', '\u2665')\nmau_mau.subjects    100 draw             : Player 2 \n- Card('7', '\u2660')\nmau_mau.subjects    100 draw             : Player 2 \n- Card('8', '\u2666')\nmau_mau.subjects    100 draw             : Player 3 \n- Card('10', '\u2665')\nmau_mau.subjects    100 draw             : Player 3 \n- Card('9', '\u2666')\nmau_mau.subjects    100 draw             : Player 3 \n- Card('Jack', '\u2660')\nmau_mau.subjects    100 draw             : Player 3 \n- Card('Jack', '\u2663')\nmau_mau.subjects    100 draw             : Player 3 \n- Card('King', '\u2665')\nmau_mau.play        28  setup_game       : Start new game: Game(Table(MauMau(5), [Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])), Player('Player 2', Hand([Card('8', '\u2665'), Card('7', '\u2663'), Card('Queen', '\u2665'), Card('7', '\u2660'), Card('8', '\u2666')])), Player('Player 3', Hand([Card('10', '\u2665'), Card('9', '\u2666'), Card('Jack', '\u2660'), Card('Jack', '\u2663'), Card('King', '\u2665')]))]))\nmau_mau.concepts    25  next_turn        : -------------------- turn 1 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Queen', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Queen', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('10', '\u2663')\n[--- SNIP ---]\nmau_mau.concepts    25  next_turn        : -------------------- turn 27 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 3', Hand([Card('King', '\u2665'), Card('Queen', '\u2666'), Card('9', '\u2660')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.strategy    65  _play            : nothing to play\nmau_mau.subjects    100 draw             : Player 3 \n- Card('8', '\u2660')\nmau_mau.concepts    25  next_turn        : -------------------- turn 28 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 1', Hand([Card('Ace', '\u2660'), Card('King', '\u2660'), Card('7', '\u2665'), Card('King', '\u2666')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.strategy    65  _play            : nothing to play\nmau_mau.subjects    100 draw             : Player 1 \n- Card('Queen', '\u2660')\nmau_mau.concepts    25  next_turn        : -------------------- turn 29 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 2', Hand([Card('King', '\u2663')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('King', '\u2663')\nroot                21  play_simple_game : And the winner is Player 2\n\n\n\nPlay a game against the computer\n\n\nPlay interactive game (and know and see everything ...):\n\n\n$ mau-mau human\n\n\n\noutput like:\n\n\nroot                53  main             : play_interactive_game() ...\nmau_mau.subjects    28  invite           : invite [Player('Eric', Hand([])), Player('John', Hand([])), Player('human', Hand([]))] to: Table(None, None)\nmau_mau.subjects    100 draw             : Eric \n- Card('Queen', '\u2660')\nmau_mau.subjects    100 draw             : Eric \n- Card('10', '\u2660')\nmau_mau.subjects    100 draw             : Eric \n- Card('Queen', '\u2663')\nmau_mau.subjects    100 draw             : Eric \n- Card('8', '\u2666')\nmau_mau.subjects    100 draw             : Eric \n- Card('7', '\u2660')\nmau_mau.subjects    100 draw             : John \n- Card('9', '\u2660')\nmau_mau.subjects    100 draw             : John \n- Card('Ace', '\u2660')\nmau_mau.subjects    100 draw             : John \n- Card('10', '\u2666')\nmau_mau.subjects    100 draw             : John \n- Card('Ace', '\u2663')\nmau_mau.subjects    100 draw             : John \n- Card('8', '\u2665')\nmau_mau.subjects    100 draw             : human \n- Card('Ace', '\u2666')\nmau_mau.subjects    100 draw             : human \n- Card('7', '\u2666')\nmau_mau.subjects    100 draw             : human \n- Card('King', '\u2665')\nmau_mau.subjects    100 draw             : human \n- Card('9', '\u2666')\nmau_mau.subjects    100 draw             : human \n- Card('King', '\u2660')\nmau_mau.play        28  setup_game       : Start new game: Game(Table(MauMau(5), [Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])), Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])), Player('human', Hand([Card('Ace', '\u2666'), Card('7', '\u2666'), Card('King', '\u2665'), Card('9', '\u2666'), Card('King', '\u2660')]))]))\nmau_mau.concepts    25  next_turn        : -------------------- turn 1 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Queen', '\u2663')\nmau_mau.concepts    25  next_turn        : -------------------- turn 2 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Queen', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Queen', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Ace', '\u2663')\n[---- SNIP ----]\nmau_mau.concepts    25  next_turn        : -------------------- turn 22 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('8', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Eric', Hand([Card('10', '\u2663'), Card('10', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule SkipNextPlayer on Card('8', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('10', '\u2665')\nmau_mau.concepts    25  next_turn        : -------------------- turn 23 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('10', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('John', Hand([Card('Ace', '\u2665'), Card('King', '\u2666'), Card('7', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('10', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Ace', '\u2665')\nmau_mau.concepts    25  next_turn        : -------------------- turn 24 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Ace', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('human', Hand([Card('King', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Ace', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nchoose card to play.\n1 -\n Card('King', '\u2665') | 1\nmau_mau.subjects    103 put              : play Card('King', '\u2665')\nroot                27  play_interactive_game: And the winner is human\n\n\n\nCollect statistics\n\n\n$ mau-mau mean_turns\n\n\n\noutput like:\n\n\nroot                42  main             : mean_turns() ...\nmau_mau.stats       35  _simulate_games  : players: 3; 1000 reps\nmau_mau.stats       12  mean_turns       : mean turns played: 34.097\n\n\n\ninput:\n\n\n$ mau-mau winner_distribution\n\n\n\noutput like:\n\n\nroot                52  main             : winner_distribution() ...\nmau_mau.stats       35  _simulate_games  : players: ('Eric', 'Terry', 'John'); 1000 reps\nmau_mau.stats       21  winner_distribution: winner distribution: {'Eric': 345, 'Terry': 327, 'John': 328}\n\n\n\ninput:\n\n\n$ mau-mau time_durations\n\n\n\noutput like:\n\n\nroot                52  main             : time_durations() ...\nmau_mau.stats       31  time_durations   : it takes 0.643 seconds to play 1000 games",
            "title": "Command line access"
        },
        {
            "location": "/guide/usage/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/guide/usage/#command-line-access",
            "text": "After installation you have an additional command in your virtualenv:  mau-mau . The default behaviour if you call it without parameters is to simulate a simple game of Mau Mau between three computer players (and you can see the hands of all the players and every step of the game).   mau-mau : Play single game with high verbosity settings in the logger  mau-mau  stats.function : e.g.  mau-mau mean_turns  - the argument will be passed to  get_function_from_name  that fetches a function object of the same name from  stats.py  and executes it. This is a very simple way to create a flexible command line interface that does not need to be changed if you create more statistics functions in  stats.py . Adding a new function to  stats.py  will automatically make it accessible through the command line interface.  mau-mau human  ... or any other argument that does not map to a function in stats: play a game against the computer",
            "title": "Command line access"
        },
        {
            "location": "/guide/usage/#run-a-simple-simulation",
            "text": "$ cd  /path/to/your/clone \n    $ mau-mau  output like:  root                53  main             : play_simple_game() ...\nmau_mau.subjects    28  invite           : invite [Player('Player 1', Hand([])), Player('Player 2', Hand([])), Player('Player 3', Hand([]))] to: Table(None, None)\nmau_mau.subjects    100 draw             : Player 1  - Card('10', '\u2663')\nmau_mau.subjects    100 draw             : Player 1  - Card('8', '\u2663')\nmau_mau.subjects    100 draw             : Player 1  - Card('Ace', '\u2663')\nmau_mau.subjects    100 draw             : Player 1  - Card('Ace', '\u2660')\nmau_mau.subjects    100 draw             : Player 1  - Card('9', '\u2665')\nmau_mau.subjects    100 draw             : Player 2  - Card('8', '\u2665')\nmau_mau.subjects    100 draw             : Player 2  - Card('7', '\u2663')\nmau_mau.subjects    100 draw             : Player 2  - Card('Queen', '\u2665')\nmau_mau.subjects    100 draw             : Player 2  - Card('7', '\u2660')\nmau_mau.subjects    100 draw             : Player 2  - Card('8', '\u2666')\nmau_mau.subjects    100 draw             : Player 3  - Card('10', '\u2665')\nmau_mau.subjects    100 draw             : Player 3  - Card('9', '\u2666')\nmau_mau.subjects    100 draw             : Player 3  - Card('Jack', '\u2660')\nmau_mau.subjects    100 draw             : Player 3  - Card('Jack', '\u2663')\nmau_mau.subjects    100 draw             : Player 3  - Card('King', '\u2665')\nmau_mau.play        28  setup_game       : Start new game: Game(Table(MauMau(5), [Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])), Player('Player 2', Hand([Card('8', '\u2665'), Card('7', '\u2663'), Card('Queen', '\u2665'), Card('7', '\u2660'), Card('8', '\u2666')])), Player('Player 3', Hand([Card('10', '\u2665'), Card('9', '\u2666'), Card('Jack', '\u2660'), Card('Jack', '\u2663'), Card('King', '\u2665')]))]))\nmau_mau.concepts    25  next_turn        : -------------------- turn 1 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Queen', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('Player 1', Hand([Card('10', '\u2663'), Card('8', '\u2663'), Card('Ace', '\u2663'), Card('Ace', '\u2660'), Card('9', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Queen', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('10', '\u2663')\n[--- SNIP ---]\nmau_mau.concepts    25  next_turn        : -------------------- turn 27 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 3', Hand([Card('King', '\u2665'), Card('Queen', '\u2666'), Card('9', '\u2660')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.strategy    65  _play            : nothing to play\nmau_mau.subjects    100 draw             : Player 3  - Card('8', '\u2660')\nmau_mau.concepts    25  next_turn        : -------------------- turn 28 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 1', Hand([Card('Ace', '\u2660'), Card('King', '\u2660'), Card('7', '\u2665'), Card('King', '\u2666')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.strategy    65  _play            : nothing to play\nmau_mau.subjects    100 draw             : Player 1  - Card('Queen', '\u2660')\nmau_mau.concepts    25  next_turn        : -------------------- turn 29 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Player 2', Hand([Card('King', '\u2663')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('King', '\u2663')\nroot                21  play_simple_game : And the winner is Player 2",
            "title": "Run a simple simulation"
        },
        {
            "location": "/guide/usage/#play-a-game-against-the-computer",
            "text": "Play interactive game (and know and see everything ...):  $ mau-mau human  output like:  root                53  main             : play_interactive_game() ...\nmau_mau.subjects    28  invite           : invite [Player('Eric', Hand([])), Player('John', Hand([])), Player('human', Hand([]))] to: Table(None, None)\nmau_mau.subjects    100 draw             : Eric  - Card('Queen', '\u2660')\nmau_mau.subjects    100 draw             : Eric  - Card('10', '\u2660')\nmau_mau.subjects    100 draw             : Eric  - Card('Queen', '\u2663')\nmau_mau.subjects    100 draw             : Eric  - Card('8', '\u2666')\nmau_mau.subjects    100 draw             : Eric  - Card('7', '\u2660')\nmau_mau.subjects    100 draw             : John  - Card('9', '\u2660')\nmau_mau.subjects    100 draw             : John  - Card('Ace', '\u2660')\nmau_mau.subjects    100 draw             : John  - Card('10', '\u2666')\nmau_mau.subjects    100 draw             : John  - Card('Ace', '\u2663')\nmau_mau.subjects    100 draw             : John  - Card('8', '\u2665')\nmau_mau.subjects    100 draw             : human  - Card('Ace', '\u2666')\nmau_mau.subjects    100 draw             : human  - Card('7', '\u2666')\nmau_mau.subjects    100 draw             : human  - Card('King', '\u2665')\nmau_mau.subjects    100 draw             : human  - Card('9', '\u2666')\nmau_mau.subjects    100 draw             : human  - Card('King', '\u2660')\nmau_mau.play        28  setup_game       : Start new game: Game(Table(MauMau(5), [Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])), Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])), Player('human', Hand([Card('Ace', '\u2666'), Card('7', '\u2666'), Card('King', '\u2665'), Card('9', '\u2666'), Card('King', '\u2660')]))]))\nmau_mau.concepts    25  next_turn        : -------------------- turn 1 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Jack', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('Eric', Hand([Card('Queen', '\u2660'), Card('10', '\u2660'), Card('Queen', '\u2663'), Card('8', '\u2666'), Card('7', '\u2660')])) is up\nmau_mau.strategy    17  play             : encountered rule DemandWantedSuit on Card('Jack', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Queen', '\u2663')\nmau_mau.concepts    25  next_turn        : -------------------- turn 2 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Queen', '\u2663')\nmau_mau.concepts    27  next_turn        : Player('John', Hand([Card('9', '\u2660'), Card('Ace', '\u2660'), Card('10', '\u2666'), Card('Ace', '\u2663'), Card('8', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Queen', '\u2663')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Ace', '\u2663')\n[---- SNIP ----]\nmau_mau.concepts    25  next_turn        : -------------------- turn 22 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('8', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('Eric', Hand([Card('10', '\u2663'), Card('10', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule SkipNextPlayer on Card('8', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('10', '\u2665')\nmau_mau.concepts    25  next_turn        : -------------------- turn 23 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('10', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('John', Hand([Card('Ace', '\u2665'), Card('King', '\u2666'), Card('7', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('10', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nmau_mau.subjects    103 put              : play Card('Ace', '\u2665')\nmau_mau.concepts    25  next_turn        : -------------------- turn 24 --------------------\nmau_mau.concepts    26  next_turn        : upcard: Card('Ace', '\u2665')\nmau_mau.concepts    27  next_turn        : Player('human', Hand([Card('King', '\u2665')])) is up\nmau_mau.strategy    17  play             : encountered rule BasicRule on Card('Ace', '\u2665')\nmau_mau.strategy    56  _play            : find card to play\nchoose card to play.\n1 -  Card('King', '\u2665') | 1\nmau_mau.subjects    103 put              : play Card('King', '\u2665')\nroot                27  play_interactive_game: And the winner is human",
            "title": "Play a game against the computer"
        },
        {
            "location": "/guide/usage/#collect-statistics",
            "text": "$ mau-mau mean_turns  output like:  root                42  main             : mean_turns() ...\nmau_mau.stats       35  _simulate_games  : players: 3; 1000 reps\nmau_mau.stats       12  mean_turns       : mean turns played: 34.097  input:  $ mau-mau winner_distribution  output like:  root                52  main             : winner_distribution() ...\nmau_mau.stats       35  _simulate_games  : players: ('Eric', 'Terry', 'John'); 1000 reps\nmau_mau.stats       21  winner_distribution: winner distribution: {'Eric': 345, 'Terry': 327, 'John': 328}  input:  $ mau-mau time_durations  output like:  root                52  main             : time_durations() ...\nmau_mau.stats       31  time_durations   : it takes 0.643 seconds to play 1000 games",
            "title": "Collect statistics"
        },
        {
            "location": "/guide/rules/",
            "text": "Rules\n\n\nBasics\n\n\n\n\nThe game is played with a regular deck of playing cards. The players are dealt each a hand of cards (usually 5). The rest are placed face down as the drawing stack. At the beginning of the game the topmost card is revealed, then the players each get a turn to play cards.\n\n\nOne can play a card if it corresponds to the suit or value of the open card. E.g. on a 10 of spades, only other spades can be played or other 10s. If a player is not able to, they draw one card from the stack. If he can play this card, he may do so, otherwise he keeps the drawn card and passes his turn. If the drawing stack is empty, the playing stack (except for the topmost card) is shuffled and turned over to serve as new drawing stack.\n\n\n-- \nWikipedia - Mau Mau\n\n\n\n\nCommon additions\n\n\nWe add the three most common rules:\n\n\n\n\nIf an eight is played, the next player is skipped\n\n\nIf a seven is played, the next player has to draw two cards. The next player can put another seven down and instead the following player will have to draw four cards (and so on).\n\n\nA Jack can can be put on anything and the player who played it can ask for a different suite to be played",
            "title": "Rules of Mau Mau"
        },
        {
            "location": "/guide/rules/#rules",
            "text": "",
            "title": "Rules"
        },
        {
            "location": "/guide/rules/#basics",
            "text": "The game is played with a regular deck of playing cards. The players are dealt each a hand of cards (usually 5). The rest are placed face down as the drawing stack. At the beginning of the game the topmost card is revealed, then the players each get a turn to play cards.  One can play a card if it corresponds to the suit or value of the open card. E.g. on a 10 of spades, only other spades can be played or other 10s. If a player is not able to, they draw one card from the stack. If he can play this card, he may do so, otherwise he keeps the drawn card and passes his turn. If the drawing stack is empty, the playing stack (except for the topmost card) is shuffled and turned over to serve as new drawing stack.  --  Wikipedia - Mau Mau",
            "title": "Basics"
        },
        {
            "location": "/guide/rules/#common-additions",
            "text": "We add the three most common rules:   If an eight is played, the next player is skipped  If a seven is played, the next player has to draw two cards. The next player can put another seven down and instead the following player will have to draw four cards (and so on).  A Jack can can be put on anything and the player who played it can ask for a different suite to be played",
            "title": "Common additions"
        },
        {
            "location": "/implementation/ooommm/",
            "text": "OOOMMM\n\n\nObvious Object Oriented Mau Mau Modelling\n\n\nSwitching into egghead mode, you could say that a game of Mau Mau can be modelled as a series of interactions between actors with adjustable attributes and behaviours modifying their own attributes and initiating reactions and attribute changes in other actors. If you call the actors objects and the behaviour methods you have a basic description of object oriented programming.\n\n\n\n\nObject-oriented design is, in its simplest form, based on a seemingly elementary idea. Computing systems perform certain actions on certain objects; to obtain flexible and reusable systems, it is better to base the structure of software on the objects than on the actions. \n\n\n-- \nBertrand Meyer - Object-Oriented Software Construction\n \n\n\n\n\nThat's all very ... abstract, isn't it? Yes it is! Meyer goes on:\n\n\n\n\nOnce you have said this, you have not really provided a definition, but rather posed a set of problems: What precisely is an object? How do you find and describe the objects? How should programs manipulate objects? What are the possible relations between objects? How does one explore the commonalities that may exist between various kinds of objects? How do these ideas relate to classical software engineering concerns such as correctness, ease of use, efficiency?\n\n\n\n\nWhat does that tell us? OO is just one of many ways of thinking about the problems you are trying to solve with software. Sometimes that way of thinking matches well with the problem you are trying to solve. There are also a lot of possibly very different answers to the questions posed by Meyer and they manifest in very different approaches to the implementation of OO in different programming languages.\n\n\nHigh level view\n\n\nOne koan in the \nZen of Python\n says: \"If the implementation is easy to explain, it may be a good idea\". Let's put this to the test and explain the implementation of our Mau Mau program by simply describing the conditions and rules of the game using a rough approximation of the programs' terminology and see if the objects and their interactions make the implementation look obvious. Objects used in the program are marked \nlike this\n, functions that describe (inter)actions are marked like \nthis\n). The game can also be described in two phases, we could call \"setup\" and \"play\". The image shows all the important elements of the simulation.\n\n\n\n\nsetup:\n The \nplayers\n are \ninvited\n to a \ngame\n at the \ntable\n. A \ndeck\n of \ncards\n is \nshuffled\n. The same amount of cards is \ndealt\n to the \nplayers\n to form their \nhand\n. One \ncard\n - the \nupcard\n - is \ndrawn\n from the \nstock\n and placed face up on the \ntable\n. The remaining cards are \npiled\n face down on the \ntable\n and form the \nstock\n. Now all is in place to \nplay\n the \ngame\n. \n\n\nplay:\n The \nplayers\n play in \nturns\n. They choose a\ncard\n that is \nplayable\n with the \nupcard\n according to the rules (same \nsuit\n or same \nvalue\n and \nspecial rules\n and place it on the \ntable\n. The played \ncard\n ist the new  \nupcard\n and the old \nupcard\n is now part of the \nwaste\n. Now the next \nplayer\n is up. If a player can't find a \ncard\n to play, they have to draw one from the \nstock\n and the next \nplayer\n is up. If the \nstock\n \nis empty\n, the \nwaste\n \ncards\n will be \nshuffled\n to form the new \nstock\n. The game is over and the \nwinner\n is found as soon as one \nplayer\n plays the last card of their \nhand\n.\n\n\nEasy enough to explain. This description of the rules and the gameplay can double already as a high level explanation of the implementation. It can also be read as an abstract story about a game, where the concrete story would be the description of an actual game. The program code can be viewed as story shape or abstract plot, with different executions of it as concrete stories. If you have no idea what I mean just watch \nKurt Vonneguts short talk about the shape of stories\n and transfer your insights into thinking about abstract program code and its concrete execution :)\n\n\nThe modelling problem we have here is a good fit to create your own data structures (which classes are), so we will model the game flow using \ncustom Python classes\n that interact in the way described above.",
            "title": "OOOMMM"
        },
        {
            "location": "/implementation/ooommm/#ooommm",
            "text": "",
            "title": "OOOMMM"
        },
        {
            "location": "/implementation/ooommm/#obvious-object-oriented-mau-mau-modelling",
            "text": "Switching into egghead mode, you could say that a game of Mau Mau can be modelled as a series of interactions between actors with adjustable attributes and behaviours modifying their own attributes and initiating reactions and attribute changes in other actors. If you call the actors objects and the behaviour methods you have a basic description of object oriented programming.   Object-oriented design is, in its simplest form, based on a seemingly elementary idea. Computing systems perform certain actions on certain objects; to obtain flexible and reusable systems, it is better to base the structure of software on the objects than on the actions.   --  Bertrand Meyer - Object-Oriented Software Construction     That's all very ... abstract, isn't it? Yes it is! Meyer goes on:   Once you have said this, you have not really provided a definition, but rather posed a set of problems: What precisely is an object? How do you find and describe the objects? How should programs manipulate objects? What are the possible relations between objects? How does one explore the commonalities that may exist between various kinds of objects? How do these ideas relate to classical software engineering concerns such as correctness, ease of use, efficiency?   What does that tell us? OO is just one of many ways of thinking about the problems you are trying to solve with software. Sometimes that way of thinking matches well with the problem you are trying to solve. There are also a lot of possibly very different answers to the questions posed by Meyer and they manifest in very different approaches to the implementation of OO in different programming languages.",
            "title": "Obvious Object Oriented Mau Mau Modelling"
        },
        {
            "location": "/implementation/ooommm/#high-level-view",
            "text": "One koan in the  Zen of Python  says: \"If the implementation is easy to explain, it may be a good idea\". Let's put this to the test and explain the implementation of our Mau Mau program by simply describing the conditions and rules of the game using a rough approximation of the programs' terminology and see if the objects and their interactions make the implementation look obvious. Objects used in the program are marked  like this , functions that describe (inter)actions are marked like  this ). The game can also be described in two phases, we could call \"setup\" and \"play\". The image shows all the important elements of the simulation.   setup:  The  players  are  invited  to a  game  at the  table . A  deck  of  cards  is  shuffled . The same amount of cards is  dealt  to the  players  to form their  hand . One  card  - the  upcard  - is  drawn  from the  stock  and placed face up on the  table . The remaining cards are  piled  face down on the  table  and form the  stock . Now all is in place to  play  the  game .   play:  The  players  play in  turns . They choose a card  that is  playable  with the  upcard  according to the rules (same  suit  or same  value  and  special rules  and place it on the  table . The played  card  ist the new   upcard  and the old  upcard  is now part of the  waste . Now the next  player  is up. If a player can't find a  card  to play, they have to draw one from the  stock  and the next  player  is up. If the  stock   is empty , the  waste   cards  will be  shuffled  to form the new  stock . The game is over and the  winner  is found as soon as one  player  plays the last card of their  hand .  Easy enough to explain. This description of the rules and the gameplay can double already as a high level explanation of the implementation. It can also be read as an abstract story about a game, where the concrete story would be the description of an actual game. The program code can be viewed as story shape or abstract plot, with different executions of it as concrete stories. If you have no idea what I mean just watch  Kurt Vonneguts short talk about the shape of stories  and transfer your insights into thinking about abstract program code and its concrete execution :)  The modelling problem we have here is a good fit to create your own data structures (which classes are), so we will model the game flow using  custom Python classes  that interact in the way described above.",
            "title": "High level view"
        },
        {
            "location": "/implementation/remarks/",
            "text": "Remarks\n\n\nCode block separation by indentation\n\n\nPython is a language where space matters ... meaning  units of code (blocks, function bodies, etc.) are delimited by a colon (\n:\n) and indentation (4 spaces by convention) of all the following lines that belong to that block. A good editor that is language aware will help with that. It \nindents\n the code automatically after ending a line with a colon . It also lets you indent and dedent entire blocks of code that are marked by pressing \nTab\n key and \noutdents\n them when prseeing \nShift + Tab\n. \n\n\nSee also: \ncode layout\n in PEP8.\n\n\nExample:\n\n\ndef my_super_function():\n    print(\nI am indented with 4 spaces\n)\n    print(\nMe too! I belong to the function\n)\nprint(\nI am not inside the function block anymore :(\n)\n\nfor currentElement in range(5):\n    print(currentElement)\n    print(\nI also belong to the loop block\n)\nprint(\nI don't belong to the loop block anymore\n)\n\n\n\n\nEverything\n in Python is an object\n\n\nEverything (even functions and classes).\n\n\nIn this \nPython Online Tutor example\n you can see how really, really everything in a running Python program is an object.\n\n\nArgument passing by assignment\n\n\n\n\nRemember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there\u2019s no alias between an argument name in the caller and callee, and so no call-by-reference per se.\n\n\n-- \nHow do I write a function with output parameters (call by reference)?\n\n\n\n\nThe way passing data to functions work in Python is \nquite specific\n, so it is important, that you are aware of it and understand it. Walk through this example in the \ntutor\n to visualize what is really happening when you pass mutable objects into functions and e.g. append elements to a list object that was passed into a function. In the example it is a list but this holds true for any object that contains references to other objects.\n\n\nChanging the state of an object that is not returned explicitly is called a \nside effect\n. Purists of certain programming paradigms would tell you that this style is messy and error prone. I won't argue with them, because I might loose. For now that's how we do it here, because than you really understand how it works. Real world programs have lots of side effects anyway so better just get used to it :) The discussion around when and how to use side effects is a huge topic. For now I just want to make you aware, that some of our functions and methods have side effects, meaning that not all changes to the state of the program are communicated purely by returning values. BTW: raising exceptions are also considered side effects and they are used a lot in Python.\n\n\nAssertions\n\n\n\n\nWhat can be asserted without evidence can be dismissed without evidence.\n\n\n-- Christopher Hitchens\n\n\n\n\nTo assert something means \"to state or express positively\". Assertions are regarded as important enough in Python, that \nassert\n is a statement\n (since Python 3 even \nprint\n is not important enough to be a statement). \nassert\n evaluates an expression and raises an \nAssertionError\n if the result of the evaluation is \nFalse\n (with a customizable message to provide more information about the problem). This can be a very simple check like making sure that an object is \ntruthy\n if evaluated as \nbool\n. \n\n\ndef spam(someObject):\n    assert someObject, \nHey! %s is not what I want!\n % (someObject)\n    print(someObject)\n\nspam([1, 2])\nspam([])\n\n\n\n\nThe assert in the \nspam\n function makes sure, that the argument passed evaluates to \nTrue\n before moving on. The first call is o.k. but the second raises the exception and prints the message as part of the traceback.\n\n\nThis is a good way to make sure that your program crashes early if the preconditions are not what you expect them. Like making sure there is a chair under your bottom before you make an attempt to sit down. Used with good measure this can safe you a lot of trouble - finding the good measure for usage of the assert statement in your code is an art and not a science.\n\n\nLook for uses of the assert statement in the code to get an idea how it might be used.\n\n\nLogging\n\n\nPython has a simple to use and convenient \nlogging module\n included. There is no reason why beginners shouldn't learn using that right away in their programs instead of cluttering the code with calls to \nprint\n. One immediate advantage is the possibility to use different \nlog levels\n in the program and adjust the output when debugging problems (e.g. \nlogging.DEBUG\n to see the full story while debugging and \nlogging.WARNING\n when running thousands of simulations, where logging would slow us down).\n\n\nWe use a \nsimple format\n and the \nconvenience function\n to initialize the logger to write to the terminal with a certain level.\n\n\nMagic methods (protocols)\n\n\nThose \n__something__()\n thingies might look scary for the uninitiated, but you will love them, once you got the idea. These methods are a way to use the internal language mechanics of Python for your own classes. They make up an important part of the Python superpowers and it's never too early to learn about them (you should at least know that they exist and that they have special meaning). Some of them are used in the model classes to create pythonic behaviour of the objects (e.g. make them iterable and comparable) and good representations.\n\n\nObject representation (\n__repr__\n)\n\n\n\n\nIf at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value\n\n\n-- \nPython docs\n\n\n\n\nIn this simple simulation this is actually possible for all objects, so why not do it? This makes it possible to copy object representations from the output and recreate them in the REPL to experiment with them. If done right this works correctly when using inheritance as well (see \nStock\n and \nWaste\n).\n\n\nThis could also be useful: \nreprlib helps making better representations\n.\n\n\nMake your own objects behave like built in data types\n\n\n\n\nlet an object have a \nlength (\n__len__\n)\n and a concept of being \nTrue\n or \nFalse\n depending on having a length \n 0 or not.\n\n\nmake an object \niterable (\n__iter__\n)\n.\n\n\n\n\nOther uses of special object attributes\n\n\nAll objects have a \nname (\n__name__\n)\n\n\nThe name attribute of module objects are set dynamically depending on the context in which the module is loaded. If the module is run like a script it has a different name than when it is imported by another module. The names of modules are used for two purposes in this program:\n\n\n\n\nSet the name of the logger object to get information from where the log was written\n\n\nIf a module is started directly it has the special name \n__main__\n - this can be used to only execute certain code if it is meant to behave like a script (as opposed to being imported as a module). This is the \ncanonic way\n to do this. \n\n\n\n\nMore resources about magic methods\n\n\n\n\nPython docs\n\n\nA Guide to Python's Magic Methods",
            "title": "Remarks"
        },
        {
            "location": "/implementation/remarks/#remarks",
            "text": "",
            "title": "Remarks"
        },
        {
            "location": "/implementation/remarks/#code-block-separation-by-indentation",
            "text": "Python is a language where space matters ... meaning  units of code (blocks, function bodies, etc.) are delimited by a colon ( : ) and indentation (4 spaces by convention) of all the following lines that belong to that block. A good editor that is language aware will help with that. It  indents  the code automatically after ending a line with a colon . It also lets you indent and dedent entire blocks of code that are marked by pressing  Tab  key and  outdents  them when prseeing  Shift + Tab .   See also:  code layout  in PEP8.  Example:  def my_super_function():\n    print( I am indented with 4 spaces )\n    print( Me too! I belong to the function )\nprint( I am not inside the function block anymore :( )\n\nfor currentElement in range(5):\n    print(currentElement)\n    print( I also belong to the loop block )\nprint( I don't belong to the loop block anymore )",
            "title": "Code block separation by indentation"
        },
        {
            "location": "/implementation/remarks/#everything-in-python-is-an-object",
            "text": "Everything (even functions and classes).  In this  Python Online Tutor example  you can see how really, really everything in a running Python program is an object.",
            "title": "Everything in Python is an object"
        },
        {
            "location": "/implementation/remarks/#argument-passing-by-assignment",
            "text": "Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there\u2019s no alias between an argument name in the caller and callee, and so no call-by-reference per se.  --  How do I write a function with output parameters (call by reference)?   The way passing data to functions work in Python is  quite specific , so it is important, that you are aware of it and understand it. Walk through this example in the  tutor  to visualize what is really happening when you pass mutable objects into functions and e.g. append elements to a list object that was passed into a function. In the example it is a list but this holds true for any object that contains references to other objects.  Changing the state of an object that is not returned explicitly is called a  side effect . Purists of certain programming paradigms would tell you that this style is messy and error prone. I won't argue with them, because I might loose. For now that's how we do it here, because than you really understand how it works. Real world programs have lots of side effects anyway so better just get used to it :) The discussion around when and how to use side effects is a huge topic. For now I just want to make you aware, that some of our functions and methods have side effects, meaning that not all changes to the state of the program are communicated purely by returning values. BTW: raising exceptions are also considered side effects and they are used a lot in Python.",
            "title": "Argument passing by assignment"
        },
        {
            "location": "/implementation/remarks/#assertions",
            "text": "What can be asserted without evidence can be dismissed without evidence.  -- Christopher Hitchens   To assert something means \"to state or express positively\". Assertions are regarded as important enough in Python, that  assert  is a statement  (since Python 3 even  print  is not important enough to be a statement).  assert  evaluates an expression and raises an  AssertionError  if the result of the evaluation is  False  (with a customizable message to provide more information about the problem). This can be a very simple check like making sure that an object is  truthy  if evaluated as  bool .   def spam(someObject):\n    assert someObject,  Hey! %s is not what I want!  % (someObject)\n    print(someObject)\n\nspam([1, 2])\nspam([])  The assert in the  spam  function makes sure, that the argument passed evaluates to  True  before moving on. The first call is o.k. but the second raises the exception and prints the message as part of the traceback.  This is a good way to make sure that your program crashes early if the preconditions are not what you expect them. Like making sure there is a chair under your bottom before you make an attempt to sit down. Used with good measure this can safe you a lot of trouble - finding the good measure for usage of the assert statement in your code is an art and not a science.  Look for uses of the assert statement in the code to get an idea how it might be used.",
            "title": "Assertions"
        },
        {
            "location": "/implementation/remarks/#logging",
            "text": "Python has a simple to use and convenient  logging module  included. There is no reason why beginners shouldn't learn using that right away in their programs instead of cluttering the code with calls to  print . One immediate advantage is the possibility to use different  log levels  in the program and adjust the output when debugging problems (e.g.  logging.DEBUG  to see the full story while debugging and  logging.WARNING  when running thousands of simulations, where logging would slow us down).  We use a  simple format  and the  convenience function  to initialize the logger to write to the terminal with a certain level.",
            "title": "Logging"
        },
        {
            "location": "/implementation/remarks/#magic-methods-protocols",
            "text": "Those  __something__()  thingies might look scary for the uninitiated, but you will love them, once you got the idea. These methods are a way to use the internal language mechanics of Python for your own classes. They make up an important part of the Python superpowers and it's never too early to learn about them (you should at least know that they exist and that they have special meaning). Some of them are used in the model classes to create pythonic behaviour of the objects (e.g. make them iterable and comparable) and good representations.",
            "title": "Magic methods (protocols)"
        },
        {
            "location": "/implementation/remarks/#object-representation-__repr__",
            "text": "If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value  --  Python docs   In this simple simulation this is actually possible for all objects, so why not do it? This makes it possible to copy object representations from the output and recreate them in the REPL to experiment with them. If done right this works correctly when using inheritance as well (see  Stock  and  Waste ).  This could also be useful:  reprlib helps making better representations .",
            "title": "Object representation (__repr__)"
        },
        {
            "location": "/implementation/remarks/#make-your-own-objects-behave-like-built-in-data-types",
            "text": "let an object have a  length ( __len__ )  and a concept of being  True  or  False  depending on having a length   0 or not.  make an object  iterable ( __iter__ ) .",
            "title": "Make your own objects behave like built in data types"
        },
        {
            "location": "/implementation/remarks/#other-uses-of-special-object-attributes",
            "text": "All objects have a  name ( __name__ )  The name attribute of module objects are set dynamically depending on the context in which the module is loaded. If the module is run like a script it has a different name than when it is imported by another module. The names of modules are used for two purposes in this program:   Set the name of the logger object to get information from where the log was written  If a module is started directly it has the special name  __main__  - this can be used to only execute certain code if it is meant to behave like a script (as opposed to being imported as a module). This is the  canonic way  to do this.    More resources about magic methods   Python docs  A Guide to Python's Magic Methods",
            "title": "Other uses of special object attributes"
        },
        {
            "location": "/implementation/explore/",
            "text": "Explore the repository\n\n\nTo explore the code repository it is best if you install the \nsources as editable\n. This means you can use the application just like as if it would be installed normally but change the code and experiment.\n\n\nplay.py\n: the most important module\n\n\nThe overall plot of the Mau Mau story can be found here. This is the entry point to start exploring the actual application. It is written in an \nimperative\n way (like a series of commands given to the computer). The code looks like a series of instructions which are to be carried out in a top down order, descending into the functions being called. The order can be influenced by loops (\nfor ... in\n or \nwhile\n) and conditioned branches (\nif ... then ... else\n). These are the basic control flow constructs Python has. There are a few more, but not many.\n\n\nBehold! The whole program in 6 lines!\n\n\ndef play_game(rulesOfTheGame, players):\n    game = setup_game(rulesOfTheGame, players)\n    while not game.over:\n        player = game.next_turn()\n        player.play_turn(game.table)\n    return game\n\n\n\n\nThis is the meat of the simulation. Here is where all the magic happens. if you call this function a game of Mau Mau will be simulated and a winner is determined. \n6 lines of code\n including the function header and the return statement. You now have read the whole plot of the fascinating Mau Mau story. If you want to understand more, you can start digging deeper and visit the definitions of the \nfunctions\n and \nclasses\n used in the \nplay_game\n function. Just start to explore the code and how the objects interact in whatever non-linear way you might prefer. This gives you an idea of how a simulation of a simple turn based card game can be implemented as a program.\n\n\nModules defining the classes\n\n\nThese look pretty different from \ngame.py\n and they are. Here is where the object oriented part of the story kicks in. If \ngame.py\n contains the plot, these modules contain the descriptions of the actors and props of the story. They describe the relevant part of the virtual universe that is created to run the simulation. It contains custom data structures (a.k.a. classes) to model the problem of simulating Mau Mau. You should be able to read through the classes and get an idea of what elements are needed to simulate a card game and how they might interact.\n\n\nconcepts.py\n\n\nClasses that stand somehow stand conceptually above the objects and subjects.\n\n\nobjects.py\n and \nsubjects.py\n\n\nI know .. in Python everything is an object, so this would be meaningless. This is also not \nsubject oriented programming\n. These are just good terms for what those classes describe in the context of the program: there are objects in the game which are manipulated by the subjects.\n\n\nrules.py\n\n\nThis contains the classes that implement the rules of Mau Mau. Start reading with the \nMauMau\n class and see if you can figure out how it works. There is always one concrete rule active on the table that is valid for the currently played round. Sometimes information gets transferred from one rule to the next (e.g. if a 7 was put on a seven, the number of draws have to accumulate). \n\n\nstrategy.py\n: how to play\n\n\nNote:\n A player has a strategy, but the player also attaches it to the active rule, so that it can be queried for the wanted suit if a Jack is on the table.\n\n\nBasicStrategy\n\n\nPlayer plays according to the rules and always chooses random antidotes if they have any (e.g. 7 on 7 to prevent having to draw) or normal cards. If playing a Jack it always asks for the suit it has the most of. \n\n\nThis can be extended upon to implement \"real\" strategies.\n\n\nHumanStrategy\n\n\nMainly to show that the existing design makes it very easy to even add interactivity to let a human play against a computer (\nmau-mau human\n).\n\n\nThe impact of this is very likely to be zero on a planetary basis, as this is just a learning tool, but in general one should be very wary of implementing something just because it's easy:\n\n\n\n\nI call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\n\n\n-- Tony Hoare\n\n\n\n\n... you have been warned.\n\n\nstats.py\n: create statistics\n\n\nContains functions to run the game simulations and collect statistics. See \nusage examples\n\n\ncli.py\n: command line access\n\n\nThis contains the code for the commandline interface. Its function \nmain\n is configured in \nsetup.py\n \nentry_points\n to act like a program called \nmau-mau\n that is accessible where the package is installed. At the moment the following can be accessed from the commandline:\n\n\nModules and configuration files for general functionality\n\n\nsetup.py\n: make installable\n\n\nThis module is what is being called, when the package is installed via pip or with \npython3 setup.py\n. This is the standard way of doing it in the Python ecosystem and it is documented \nhere\n. \n\n\ntox.ini\n: developer task automation\n\n\nThis \nINI\n file configures tasks that can run with the tox commands. The primary goal of tox is to automate testing and act as a frontend for CI, but it can be used for automating other developer tasks as well. See also \nthe developer documentation\n for this tox.ini.\n\n\n.travis.yml\n and \nappveyor.yml\n: CI for different versions and osses\n\n\nSee \ndocumentation about CI\n\n\nmkdocs.yml\n: developer task automation\n\n\nSee the \ndocumentation for the documentation\n (I'm not kidding ...).",
            "title": "Explore the code"
        },
        {
            "location": "/implementation/explore/#explore-the-repository",
            "text": "To explore the code repository it is best if you install the  sources as editable . This means you can use the application just like as if it would be installed normally but change the code and experiment.",
            "title": "Explore the repository"
        },
        {
            "location": "/implementation/explore/#playpy-the-most-important-module",
            "text": "The overall plot of the Mau Mau story can be found here. This is the entry point to start exploring the actual application. It is written in an  imperative  way (like a series of commands given to the computer). The code looks like a series of instructions which are to be carried out in a top down order, descending into the functions being called. The order can be influenced by loops ( for ... in  or  while ) and conditioned branches ( if ... then ... else ). These are the basic control flow constructs Python has. There are a few more, but not many.  Behold! The whole program in 6 lines!  def play_game(rulesOfTheGame, players):\n    game = setup_game(rulesOfTheGame, players)\n    while not game.over:\n        player = game.next_turn()\n        player.play_turn(game.table)\n    return game  This is the meat of the simulation. Here is where all the magic happens. if you call this function a game of Mau Mau will be simulated and a winner is determined.  6 lines of code  including the function header and the return statement. You now have read the whole plot of the fascinating Mau Mau story. If you want to understand more, you can start digging deeper and visit the definitions of the  functions  and  classes  used in the  play_game  function. Just start to explore the code and how the objects interact in whatever non-linear way you might prefer. This gives you an idea of how a simulation of a simple turn based card game can be implemented as a program.",
            "title": "play.py: the most important module"
        },
        {
            "location": "/implementation/explore/#modules-defining-the-classes",
            "text": "These look pretty different from  game.py  and they are. Here is where the object oriented part of the story kicks in. If  game.py  contains the plot, these modules contain the descriptions of the actors and props of the story. They describe the relevant part of the virtual universe that is created to run the simulation. It contains custom data structures (a.k.a. classes) to model the problem of simulating Mau Mau. You should be able to read through the classes and get an idea of what elements are needed to simulate a card game and how they might interact.",
            "title": "Modules defining the classes"
        },
        {
            "location": "/implementation/explore/#conceptspy",
            "text": "Classes that stand somehow stand conceptually above the objects and subjects.",
            "title": "concepts.py"
        },
        {
            "location": "/implementation/explore/#objectspy-and-subjectspy",
            "text": "I know .. in Python everything is an object, so this would be meaningless. This is also not  subject oriented programming . These are just good terms for what those classes describe in the context of the program: there are objects in the game which are manipulated by the subjects.",
            "title": "objects.py and subjects.py"
        },
        {
            "location": "/implementation/explore/#rulespy",
            "text": "This contains the classes that implement the rules of Mau Mau. Start reading with the  MauMau  class and see if you can figure out how it works. There is always one concrete rule active on the table that is valid for the currently played round. Sometimes information gets transferred from one rule to the next (e.g. if a 7 was put on a seven, the number of draws have to accumulate).",
            "title": "rules.py"
        },
        {
            "location": "/implementation/explore/#strategypy-how-to-play",
            "text": "Note:  A player has a strategy, but the player also attaches it to the active rule, so that it can be queried for the wanted suit if a Jack is on the table.",
            "title": "strategy.py: how to play"
        },
        {
            "location": "/implementation/explore/#basicstrategy",
            "text": "Player plays according to the rules and always chooses random antidotes if they have any (e.g. 7 on 7 to prevent having to draw) or normal cards. If playing a Jack it always asks for the suit it has the most of.   This can be extended upon to implement \"real\" strategies.",
            "title": "BasicStrategy"
        },
        {
            "location": "/implementation/explore/#humanstrategy",
            "text": "Mainly to show that the existing design makes it very easy to even add interactivity to let a human play against a computer ( mau-mau human ).  The impact of this is very likely to be zero on a planetary basis, as this is just a learning tool, but in general one should be very wary of implementing something just because it's easy:   I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.  -- Tony Hoare   ... you have been warned.",
            "title": "HumanStrategy"
        },
        {
            "location": "/implementation/explore/#statspy-create-statistics",
            "text": "Contains functions to run the game simulations and collect statistics. See  usage examples",
            "title": "stats.py: create statistics"
        },
        {
            "location": "/implementation/explore/#clipy-command-line-access",
            "text": "This contains the code for the commandline interface. Its function  main  is configured in  setup.py   entry_points  to act like a program called  mau-mau  that is accessible where the package is installed. At the moment the following can be accessed from the commandline:",
            "title": "cli.py: command line access"
        },
        {
            "location": "/implementation/explore/#modules-and-configuration-files-for-general-functionality",
            "text": "",
            "title": "Modules and configuration files for general functionality"
        },
        {
            "location": "/implementation/explore/#setuppy-make-installable",
            "text": "This module is what is being called, when the package is installed via pip or with  python3 setup.py . This is the standard way of doing it in the Python ecosystem and it is documented  here .",
            "title": "setup.py: make installable"
        },
        {
            "location": "/implementation/explore/#toxini-developer-task-automation",
            "text": "This  INI  file configures tasks that can run with the tox commands. The primary goal of tox is to automate testing and act as a frontend for CI, but it can be used for automating other developer tasks as well. See also  the developer documentation  for this tox.ini.",
            "title": "tox.ini: developer task automation"
        },
        {
            "location": "/implementation/explore/#travisyml-and-appveyoryml-ci-for-different-versions-and-osses",
            "text": "See  documentation about CI",
            "title": ".travis.yml and appveyor.yml: CI for different versions and osses"
        },
        {
            "location": "/implementation/explore/#mkdocsyml-developer-task-automation",
            "text": "See the  documentation for the documentation  (I'm not kidding ...).",
            "title": "mkdocs.yml: developer task automation"
        },
        {
            "location": "/dev/getting-started/",
            "text": "Getting started\n\n\nNOTE:\n Please replace \n/path/to/your/clone\n with the actual path on your computer.\n\n\nTo work on the code:\n\n\n\n\nfork\n the code \n\n\nclone\n the repository to \npath/to/your/clone\n (wherever that is).\n\n\n\n\n... and install the code as editable in a \nvirtualenv\n:\n\n\n$ \nactivate your virtualenv\n\n$ cd \npath/to/your/clone\n\n$ pip install -e '.[all]'\n\n\n\noutput like:\n\n\nObtaining file:///\n/path/to/your/clone\n\nInstalling collected packages: mau-mau\n  Running setup.py develop for mau-mau\nSuccessfully installed mau-mau",
            "title": "Getting started"
        },
        {
            "location": "/dev/getting-started/#getting-started",
            "text": "NOTE:  Please replace  /path/to/your/clone  with the actual path on your computer.  To work on the code:   fork  the code   clone  the repository to  path/to/your/clone  (wherever that is).   ... and install the code as editable in a  virtualenv :  $  activate your virtualenv \n$ cd  path/to/your/clone \n$ pip install -e '.[all]'  output like:  Obtaining file:/// /path/to/your/clone \nInstalling collected packages: mau-mau\n  Running setup.py develop for mau-mau\nSuccessfully installed mau-mau",
            "title": "Getting started"
        },
        {
            "location": "/dev/static-analysis/",
            "text": "Static code analysis\n\n\nFlake8\n\n\nFlake8\n is a collection of tools that analyze the code without running it. This can be understood as a first line of defense and you learn about style and complexity problems you might have in your code.\n\n\nRun flake8 analysis:\n\n\n$ cd \npath/to/your/clone\n\n$ flake8 mau_mau/ tests/ --show-source\n\n\n\nIf flake8 is happy it won't produce any output. If not, it looks ike this:\n\n\nmau_mau/cli.py:39:80: E501 line too long (84 \n 79 characters)\n####################################################################################\n                                                                               ^\nmau_mau/cli.py:41:1: E302 expected 2 blank lines, found 1\ndef simple_parse_args(argv):\n^\n\n\n\nQuantified Code \n\n\nQuantified Code offers static code analysis as a webservice that connects to your Github repository. It is an interesting new approach and can teach you a lot about the code you write. It is not just pointing out problems it tries to educate about the reasoning behind the warnings and even helps to fix the problems. Definitely \nworth a look\n.",
            "title": "Static code analysis"
        },
        {
            "location": "/dev/static-analysis/#static-code-analysis",
            "text": "",
            "title": "Static code analysis"
        },
        {
            "location": "/dev/static-analysis/#flake8",
            "text": "Flake8  is a collection of tools that analyze the code without running it. This can be understood as a first line of defense and you learn about style and complexity problems you might have in your code.  Run flake8 analysis:  $ cd  path/to/your/clone \n$ flake8 mau_mau/ tests/ --show-source  If flake8 is happy it won't produce any output. If not, it looks ike this:  mau_mau/cli.py:39:80: E501 line too long (84   79 characters)\n####################################################################################\n                                                                               ^\nmau_mau/cli.py:41:1: E302 expected 2 blank lines, found 1\ndef simple_parse_args(argv):\n^",
            "title": "Flake8"
        },
        {
            "location": "/dev/static-analysis/#quantified-code",
            "text": "Quantified Code offers static code analysis as a webservice that connects to your Github repository. It is an interesting new approach and can teach you a lot about the code you write. It is not just pointing out problems it tries to educate about the reasoning behind the warnings and even helps to fix the problems. Definitely  worth a look .",
            "title": "Quantified Code"
        },
        {
            "location": "/dev/tests/",
            "text": "Automatic tests\n\n\npy.test\n is my tool of choice. There is aso a \nstandard library solution\n, which has to much API overhead for my taste. py.test does some very \nclever things\n to let you use the assertion statement directly and you get much better failure reports. This makes for much cleaner test code and less painful testing. \n\n\nNote\n: test modules are here: \ntests/\n\n\nThe ability to write simple functions to test your code cannot be developed early enough, so why not start this right away as well? The examples are dead simple and not covering much yet, but show that it's not rocket science to write automatic tests for your code. Pytest makes it possible to use the inbuilt \nassert\n for writing tests.\n\n\nRunning py.test from the command line\n\n\npy.test looks for modules with the pattern \ntest_*.py\n downwards from your \ncwd\n. In those modules it looks for \ndef test_*\n and \nclass Test*\n. After collecting everything fitting those patterns it execute all test functions and reports back.\n\n\n$ cd \n/path/to/your/clone\n\n$ py.test\n\n\n\nExample for a successful run:\n\n\n========================== test session starts ==========================\nplatform linux -- Python 3.4.3, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir: \n/path/to/your/clone\n, inifile: tox.ini\ncollected 13 items \ntests/test_pile.py .....\ntests/test_player.py ...\ntests/test_sim.py .....\n======================= 13 passed in 0.03 seconds =======================\n\n\n\nExample for a not so successful run:\n\n\n======================= test session starts =============================\nplatform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir: \n/path/to/your/clone\n, inifile: tox.ini\ncollected 35 items\n\ntests/test_concepts.py ...................\ntests/test_objects.py ..F..\ntests/test_player.py ...\ntests/test_rules.py ...\ntests/test_sim.py .....\n======================== short test summary info ========================\nFAIL tests/test_objects.py::test_non_empty_stock\n\n=============================== FAILURES ================================\n_________________________ test_non_empty_stock __________________________\n\n    def test_non_empty_stock():\n\n       assert not Stock([0])\nE       assert not Stock([0])\nE        +  where Stock([0]) = Stock([0])\n\ntests/test_objects.py:17: AssertionError\n==================== 1 failed, 34 passed in 0.21 seconds ================\n\n\n\nThis test failed not because the code is broken, but because I made a wrong assertion about the behaviour of the \nStock\n class. If you pass a list when you create the class you should not expect is to be empty afterwards.\n\n\nAutomatically run tests on changes:\n\n\nIf you want to take this one step further and have the tests being run automatically every time the code changes, you can:\n\n\n$ pip install pytest-watch\n$ cd \n/path/to/your/clone\n\n$ ptw --onfail 'notify-send --urgency=critical \"FAIL\"' --onpass 'notify-send \"PASSED\"'\n\n\n\nnotify-send\n is the way how I can send desktop notifications from the commandline in my os (\nLinux\n). There are lots of ways to do this on every os - even \nWindows\n and \nMac\n.\n\n\nRun py.test from PyCharm\n\n\nPreparation\n\n\nThe default testrunner in PyCharm is Unittest. You have to switch to py.test like so: \n\n \nFind Action: \ndefault testrunner\n: set to py.test \n\n accept offer to install it in your project virtualenv or do it yourself with \npip install pytest\n\n\nRunning tests\n\n\nDepending on where you are, you can run all tests are part of them. The magic action is \nrun context configuration\n. It runs what is sensible in the context. If your focus is in a normal script it runs the script and if the focus is in a module defining tests it will run the configured testrunner with the tests. Running the context configuration with ...\n\n\n\n\nfocus in the editor, inside a specific test\n\n\nfocus in the editor on the line defining a class containing tests\n\n\nfocus in the \nProject Tool Window\n, choose the \ntests/\n folder and \n\n\n\n\n... all yields different results as which tests are run (and they are what you would intuitively expect).\n\n\nExecutable documentation with doctests\n\n\nYou can write simple examples that can double as tests directly in documentation strings. They are called \ndoctests\n. You can \nrun them directly from PyCharm\n as well.\n\n\nFor an example in the code see \nconcepts.py",
            "title": "Automatic tests"
        },
        {
            "location": "/dev/tests/#automatic-tests",
            "text": "py.test  is my tool of choice. There is aso a  standard library solution , which has to much API overhead for my taste. py.test does some very  clever things  to let you use the assertion statement directly and you get much better failure reports. This makes for much cleaner test code and less painful testing.   Note : test modules are here:  tests/  The ability to write simple functions to test your code cannot be developed early enough, so why not start this right away as well? The examples are dead simple and not covering much yet, but show that it's not rocket science to write automatic tests for your code. Pytest makes it possible to use the inbuilt  assert  for writing tests.",
            "title": "Automatic tests"
        },
        {
            "location": "/dev/tests/#running-pytest-from-the-command-line",
            "text": "py.test looks for modules with the pattern  test_*.py  downwards from your  cwd . In those modules it looks for  def test_*  and  class Test* . After collecting everything fitting those patterns it execute all test functions and reports back.  $ cd  /path/to/your/clone \n$ py.test  Example for a successful run:  ========================== test session starts ==========================\nplatform linux -- Python 3.4.3, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir:  /path/to/your/clone , inifile: tox.ini\ncollected 13 items \ntests/test_pile.py .....\ntests/test_player.py ...\ntests/test_sim.py .....\n======================= 13 passed in 0.03 seconds =======================  Example for a not so successful run:  ======================= test session starts =============================\nplatform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir:  /path/to/your/clone , inifile: tox.ini\ncollected 35 items\n\ntests/test_concepts.py ...................\ntests/test_objects.py ..F..\ntests/test_player.py ...\ntests/test_rules.py ...\ntests/test_sim.py .....\n======================== short test summary info ========================\nFAIL tests/test_objects.py::test_non_empty_stock\n\n=============================== FAILURES ================================\n_________________________ test_non_empty_stock __________________________\n\n    def test_non_empty_stock():        assert not Stock([0])\nE       assert not Stock([0])\nE        +  where Stock([0]) = Stock([0])\n\ntests/test_objects.py:17: AssertionError\n==================== 1 failed, 34 passed in 0.21 seconds ================  This test failed not because the code is broken, but because I made a wrong assertion about the behaviour of the  Stock  class. If you pass a list when you create the class you should not expect is to be empty afterwards.",
            "title": "Running py.test from the command line"
        },
        {
            "location": "/dev/tests/#automatically-run-tests-on-changes",
            "text": "If you want to take this one step further and have the tests being run automatically every time the code changes, you can:  $ pip install pytest-watch\n$ cd  /path/to/your/clone \n$ ptw --onfail 'notify-send --urgency=critical \"FAIL\"' --onpass 'notify-send \"PASSED\"'  notify-send  is the way how I can send desktop notifications from the commandline in my os ( Linux ). There are lots of ways to do this on every os - even  Windows  and  Mac .",
            "title": "Automatically run tests on changes:"
        },
        {
            "location": "/dev/tests/#run-pytest-from-pycharm",
            "text": "",
            "title": "Run py.test from PyCharm"
        },
        {
            "location": "/dev/tests/#preparation",
            "text": "The default testrunner in PyCharm is Unittest. You have to switch to py.test like so:    Find Action:  default testrunner : set to py.test   accept offer to install it in your project virtualenv or do it yourself with  pip install pytest",
            "title": "Preparation"
        },
        {
            "location": "/dev/tests/#running-tests",
            "text": "Depending on where you are, you can run all tests are part of them. The magic action is  run context configuration . It runs what is sensible in the context. If your focus is in a normal script it runs the script and if the focus is in a module defining tests it will run the configured testrunner with the tests. Running the context configuration with ...   focus in the editor, inside a specific test  focus in the editor on the line defining a class containing tests  focus in the  Project Tool Window , choose the  tests/  folder and    ... all yields different results as which tests are run (and they are what you would intuitively expect).",
            "title": "Running tests"
        },
        {
            "location": "/dev/tests/#executable-documentation-with-doctests",
            "text": "You can write simple examples that can double as tests directly in documentation strings. They are called  doctests . You can  run them directly from PyCharm  as well.  For an example in the code see  concepts.py",
            "title": "Executable documentation with doctests"
        },
        {
            "location": "/dev/tox/",
            "text": "Tox - a developer frontend\n\n\nTox\n is one abstraction level up from py.test and serves as a command line frontend for different kinds of tests and also acts a a frontend for external test runners as part of \nCI\n. It automatically creates an environment for the tests, installs dependencies, does whatever else is needed for test preparation and outputs the results.\n\n\nIt can also be (ab)used to act as a frontend for other tasks developers have to do as part of their work. In this project we also use it for building and developing the documentation.\n\n\nRun static code analysis:\n\n\n$ cd \n/path/to/your/clone\n\n$ tox -e static\n\n\n\noutput like: \n\n\nstatic create: \n/path/to/your/clone\n/.tox/static\nstatic installdeps: flake8\nstatic develop-inst: \n/path/to/your/clone\n\nstatic installed: flake8==2.5.4,-e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,mccabe==0.4.0,pep8==1.7.0,pyflakes==1.0.0\nstatic runtests: PYTHONHASHSEED='3703953266'\nstatic runtests: commands[0] | flake8 \n/path/to/your/clone\n/mau_mau \n/path/to/your/clone\n/tests --show-source\n\n\n\ncommand line usage:\n\n\n$ cd \n/path/to/your/clone\n\n$ tox -e tests\n\n\n\noutput like: \n\n\ntests develop-inst-nodeps: \n/path/to/your/clone\n\ntests installed: -e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,py==1.4.31,pytest==2.9.1\ntests runtests: PYTHONHASHSEED='2804594378'\ntests runtests: commands[0] | py.test \n/path/to/your/clone\n/tests\n============================= test session starts =============================\nplatform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir: \n/path/to/your/clone\n, inifile: tox.ini\ncollected 35 items\n\ntests/test_concepts.py ...................\ntests/test_objects.py .....\ntests/test_player.py ...\ntests/test_rules.py ...\ntests/test_sim.py .....\n\n========================== 35 passed in 0.04 seconds ==========================\n___________________________________ summary ___________________________________\n  tests: commands succeeded\n  congratulations :)\n\n\n\nThis is a very simple setup. There are many more \nconfiguration options\n\n\nBTW:\n just running \ntox\n without parameters runs all the environments defined in envlist.",
            "title": "Using Tox"
        },
        {
            "location": "/dev/tox/#tox-a-developer-frontend",
            "text": "Tox  is one abstraction level up from py.test and serves as a command line frontend for different kinds of tests and also acts a a frontend for external test runners as part of  CI . It automatically creates an environment for the tests, installs dependencies, does whatever else is needed for test preparation and outputs the results.  It can also be (ab)used to act as a frontend for other tasks developers have to do as part of their work. In this project we also use it for building and developing the documentation.  Run static code analysis:  $ cd  /path/to/your/clone \n$ tox -e static  output like:   static create:  /path/to/your/clone /.tox/static\nstatic installdeps: flake8\nstatic develop-inst:  /path/to/your/clone \nstatic installed: flake8==2.5.4,-e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,mccabe==0.4.0,pep8==1.7.0,pyflakes==1.0.0\nstatic runtests: PYTHONHASHSEED='3703953266'\nstatic runtests: commands[0] | flake8  /path/to/your/clone /mau_mau  /path/to/your/clone /tests --show-source  command line usage:  $ cd  /path/to/your/clone \n$ tox -e tests  output like:   tests develop-inst-nodeps:  /path/to/your/clone \ntests installed: -e git+git@github.com:obestwalter/mau-mau.git@46669a6073d233b8a27eee4995c63f03a4aec7a3#egg=mau_mau,py==1.4.31,pytest==2.9.1\ntests runtests: PYTHONHASHSEED='2804594378'\ntests runtests: commands[0] | py.test  /path/to/your/clone /tests\n============================= test session starts =============================\nplatform linux -- Python 3.4.4, pytest-2.9.1, py-1.4.31, pluggy-0.3.1\nrootdir:  /path/to/your/clone , inifile: tox.ini\ncollected 35 items\n\ntests/test_concepts.py ...................\ntests/test_objects.py .....\ntests/test_player.py ...\ntests/test_rules.py ...\ntests/test_sim.py .....\n\n========================== 35 passed in 0.04 seconds ==========================\n___________________________________ summary ___________________________________\n  tests: commands succeeded\n  congratulations :)  This is a very simple setup. There are many more  configuration options  BTW:  just running  tox  without parameters runs all the environments defined in envlist.",
            "title": "Tox - a developer frontend"
        },
        {
            "location": "/dev/ci/",
            "text": "Continuous integration\n\n\nTravis CI\n\n\nTravis CI\n is a webservice that connects to your Github account and runs your tests for you. The configuration is in \n.travis.yml\n (\nYAML\n format).\n\n\nAs we're using tox already the integration with ci is very simple: just install and run \ntox\n on the build machine and we're done.\n\n\nThe badge on top of the projects \nREADME.md\n shows the \nbuild status from Travis CI\n.\n\n\nThis is a very simple setup. There are many more \nconfiguration options\n.\n\n\nAppveyor\n\n\nAppveyor\n is the pendant to run tests on Windows osses.\n\n\nThe same as for Travis Ci applies to appveyor. The configuration is slightly different but the principle is the same: \n.appveyor.yml\n (\nYAML\n format)\n\n\nThe badge on top of the projects \nREADME.md\n shows the \nbuild status from Travis CI\n.",
            "title": "Continuous intergration"
        },
        {
            "location": "/dev/ci/#continuous-integration",
            "text": "",
            "title": "Continuous integration"
        },
        {
            "location": "/dev/ci/#travis-ci",
            "text": "Travis CI  is a webservice that connects to your Github account and runs your tests for you. The configuration is in  .travis.yml  ( YAML  format).  As we're using tox already the integration with ci is very simple: just install and run  tox  on the build machine and we're done.  The badge on top of the projects  README.md  shows the  build status from Travis CI .  This is a very simple setup. There are many more  configuration options .",
            "title": "Travis CI"
        },
        {
            "location": "/dev/ci/#appveyor",
            "text": "Appveyor  is the pendant to run tests on Windows osses.  The same as for Travis Ci applies to appveyor. The configuration is slightly different but the principle is the same:  .appveyor.yml  ( YAML  format)  The badge on top of the projects  README.md  shows the  build status from Travis CI .",
            "title": "Appveyor"
        },
        {
            "location": "/dev/docs/",
            "text": "Documentation building and hosting\n\n\nMkDocs and Github pages\n\n\nMkDocs\n\n\nThe documentation is generated with \nMkDocs\n and it lives in \ndocs/\n. The configuration is in \nmkdocs.yml\n (\nYAML\n format).\n\n\nMarkdown\n is an easy to learn format that is the default on \nGithub\n and \nStack Overflow\n. It is much easier on the eye than restructuredText - the established standard in the Python world. But it is also not as powerful. For more complex documentation \nSphinx\n and \nrestructuredText\n might be better suited.\n\n\nGithub pages\n\n\nGithub offers to host the project documentation on \nGithub Pages\n. MkDocs has an inbuilt deploy functionality do push the documentation there. The pages are hosted as project homepage on \ngithub.io\n.\n\n\nWorking on the documentation\n\n\nWhen you work on the documentation you can start a local server:\n\n\n$ cd \npath/to/your/clone\n\n$ tox -e docs-auto\n\n\n\nThis prepares an environment and runs \nmkdocs serve\n. You can do it directly already. Using tox here is a bit of overkill, but serves to demonstrate, that you can use tox for automating and standardizing all kinds of development tasks. \n\n\nThe documentation is now served on \nlocalhost:8000\n and changes are automatically detected and the website is reloaded.\n\n\nTidy up the build in case of big changes or problems:\n\n\n$ tox -e docs-clean\n\n\n\nDeploying the documentation\n\n\nIf you have push rights for the repository you can deploy the current documentation with:\n\n\n$ cd \npath/to/your/clone\n\n$ tox -e docs-deploy",
            "title": "Working on documentation"
        },
        {
            "location": "/dev/docs/#documentation-building-and-hosting",
            "text": "",
            "title": "Documentation building and hosting"
        },
        {
            "location": "/dev/docs/#mkdocs-and-github-pages",
            "text": "",
            "title": "MkDocs and Github pages"
        },
        {
            "location": "/dev/docs/#mkdocs",
            "text": "The documentation is generated with  MkDocs  and it lives in  docs/ . The configuration is in  mkdocs.yml  ( YAML  format).  Markdown  is an easy to learn format that is the default on  Github  and  Stack Overflow . It is much easier on the eye than restructuredText - the established standard in the Python world. But it is also not as powerful. For more complex documentation  Sphinx  and  restructuredText  might be better suited.",
            "title": "MkDocs"
        },
        {
            "location": "/dev/docs/#github-pages",
            "text": "Github offers to host the project documentation on  Github Pages . MkDocs has an inbuilt deploy functionality do push the documentation there. The pages are hosted as project homepage on  github.io .",
            "title": "Github pages"
        },
        {
            "location": "/dev/docs/#working-on-the-documentation",
            "text": "When you work on the documentation you can start a local server:  $ cd  path/to/your/clone \n$ tox -e docs-auto  This prepares an environment and runs  mkdocs serve . You can do it directly already. Using tox here is a bit of overkill, but serves to demonstrate, that you can use tox for automating and standardizing all kinds of development tasks.   The documentation is now served on  localhost:8000  and changes are automatically detected and the website is reloaded.  Tidy up the build in case of big changes or problems:  $ tox -e docs-clean",
            "title": "Working on the documentation"
        },
        {
            "location": "/dev/docs/#deploying-the-documentation",
            "text": "If you have push rights for the repository you can deploy the current documentation with:  $ cd  path/to/your/clone \n$ tox -e docs-deploy",
            "title": "Deploying the documentation"
        }
    ]
}